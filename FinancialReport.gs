/**
 * Financial Reporting Logic.
 *
 * NOTE: This code assumes that the global constants
 * (SHEET_ID, CARD_CUT_OFF_DAY, LOCAL_CURRENCY, GEMINI_API_KEY)
 * are defined correctly in another file (e.g., 'Code.gs').
 */

// -------------------------------------------------------------
// ðŸ“Š MAIN FUNCTION: FINANCIAL REPORT AND PREDICTION GENERATION
// -------------------------------------------------------------

/**
 * Function that analyzes all recorded expenses in the sheet, groups them,
 * and requests Gemini to generate a summary and spending prediction report.
 */
function generateFinancialReport() {
  const SCRIPT_TITLE = 'Financial Expense Report';
  
  // 1. Get data and verify configuration
  if (typeof SHEET_ID === 'undefined' || typeof GEMINI_API_KEY === 'undefined' || GEMINI_API_KEY === 'YOUR_GEMINI_API_KEY') {
    Browser.msgBox(SCRIPT_TITLE, 'Configuration Error: Ensure that SHEET_ID and GEMINI_API_KEY are correctly defined.', Browser.Buttons.OK);
    return;
  }
  
  const spreadsheet = SpreadsheetApp.openById(SHEET_ID);
  const expensesSheet = spreadsheet.getSheetByName('Expenses');
  
  if (!expensesSheet || expensesSheet.getLastRow() < 2) {
    Browser.msgBox(SCRIPT_TITLE, 'Error: Insufficient data in the "Expenses" sheet to generate a report.', Browser.Buttons.OK);
    return;
  }
  
  // Gets all data excluding the header (row 1). Assumes 8 columns.
  // It's important to use the actual data column range (1 to 8).
  const data = expensesSheet.getRange(2, 1, expensesSheet.getLastRow() - 1, 8).getValues(); 

  const today = new Date();
  const totalsByCategory = {};
  const monthlyTotals = {};
  let totalSpentInCycle = 0;
  
  // Determines the analysis period (Card Cycle or Calendar Month)
  const cycleStartDate = getCycleStartDate(today, CARD_CUT_OFF_DAY);
  
  // 2. Process and group data
  data.forEach(row => {
    // Ensure the amount is a valid number (Column D, index 3 is Local Amount)
    const amount = typeof row[3] === 'number' ? row[3] : parseFloat(row[3]) || 0;
    
    if (amount > 0) {
      const date = new Date(row[0]); // Column A: Date
      const category = row[2]; Â  Â  Â  Â // Column C: Category
      
      // a. Monthly grouping (for historical prediction)
      const monthKey = Utilities.formatDate(date, Session.getScriptTimeZone(), 'yyyy-MM');
      monthlyTotals[monthKey] = (monthlyTotals[monthKey] || 0) + amount;

      // b. Grouping by Current Cycle (for summary)
      if (date >= cycleStartDate && date <= today) {
        totalSpentInCycle += amount;
        totalsByCategory[category] = (totalsByCategory[category] || 0) + amount;
      }
    }
  });
  
  // 3. Prepare historical data for prediction
  const monthlyHistory = Object.keys(monthlyTotals)
    .sort()
    .map(key => ({ month: key, total: monthlyTotals[key] }));
  
  // 4. Structure the JSON for Gemini
  const totalDays = getTotalDaysInCycle(cycleStartDate, CARD_CUT_OFF_DAY);
  const daysElapsed = Math.ceil((today.getTime() - cycleStartDate.getTime()) / (1000 * 3600 * 24));
  
  const dataForGemini = {
    local_currency: LOCAL_CURRENCY,
    analysis_period: CARD_CUT_OFF_DAY > 0 ? `Card Cycle (Cut-off Day ${CARD_CUT_OFF_DAY})` : 'Calendar Month',
    cycle_start_date: Utilities.formatDate(cycleStartDate, Session.getScriptTimeZone(), 'yyyy-MM-dd'),
    report_date: Utilities.formatDate(today, Session.getScriptTimeZone(), 'yyyy-MM-dd'),
    total_spent_in_cycle: totalSpentInCycle,
    expenses_by_category: totalsByCategory,
    monthly_history: monthlyHistory,
    days_elapsed_in_cycle: daysElapsed,
    total_days_in_cycle: totalDays,
    days_remaining_in_cycle: Math.max(0, totalDays - daysElapsed)
  };
  
  // 5. Call Gemini to generate the report
  const reportText = analyzeDataWithGemini(JSON.stringify(dataForGemini));
  
  // 6. Write the result to the Report sheet
  const reportSheet = createReportSheet(spreadsheet);
  
  // Write the date and report to A1
  const finalReport = `**Report Generated by Gemini - ${Utilities.formatDate(today, Session.getScriptTimeZone(), 'dd/MM/yyyy HH:mm')}**\n\n` + reportText;
  
  reportSheet.getRange('A1').setValue(finalReport);
  reportSheet.getRange('A1').setWrap(true); // Wrap text for better reading

  // Final message
  Browser.msgBox(SCRIPT_TITLE, `âœ… Report generated and saved in the "Gemini Report" sheet.`, Browser.Buttons.OK);
}

/**
 * Ensures the report spreadsheet exists.
 * @param {GoogleAppsScript.Spreadsheet.Spreadsheet} spreadsheet - The active spreadsheet.
 * @returns {GoogleAppsScript.Spreadsheet.Sheet} The report sheet.
 */
function createReportSheet(spreadsheet) {
  const SHEET_NAME = 'Gemini Report';
  let sheet = spreadsheet.getSheetByName(SHEET_NAME);
  
  if (!sheet) {
    sheet = spreadsheet.insertSheet(SHEET_NAME);
  } else {
    // Clear previous content for the new report
    sheet.clearContents();
  }
  
  // Set column width to facilitate reading the Markdown report
  sheet.setColumnWidth(1, 800); // Column A width to 800 pixels
  
  return sheet;
}

// -------------------------------------------------------------
// DATE UTILITY FUNCTIONS
// -------------------------------------------------------------

/**
 * Helper function to determine the start date of the current cycle
 * based on the defined cut-off day.
 * @param {Date} today - Today's date.
 * @param {number} cutOffDay - The card cut-off day (1-28). 0 for calendar month.
 * @returns {Date} The cycle start date.
 */
function getCycleStartDate(today, cutOffDay) {
  const day = today.getDate();
  const year = today.getFullYear();
  const month = today.getMonth(); // 0-11
  
  if (cutOffDay === 0) {
    // Calendar month: the cycle always starts on day 1 of the current month
    return new Date(year, month, 1);
  }
  
  // Card Cycle
  let startDate;
  
  if (day > cutOffDay) {
    // The current cycle started the day after the cut-off this month.
    startDate = new Date(year, month, cutOffDay + 1);
  } else {
    // The current cycle started the day after the cut-off last month.
    const lastMonth = month === 0 ? 11 : month - 1;
    const lastYear = month === 0 ? year - 1 : year;
    startDate = new Date(lastYear, lastMonth, cutOffDay + 1);
  }
  
  Logger.log(`Cycle Start Date: ${startDate.toDateString()}`);
  return startDate;
}

/**
 * Helper function to determine the total days in the billing cycle.
 * The cycle runs from (Cut-off Day + 1) of month N to (Cut-off Day) of month N+1.
 * @param {Date} cycleStartDate - Cycle start date.
 * @param {number} cutOffDay - The cut-off day.
 * @returns {number} Total number of days in the cycle.
 */
function getTotalDaysInCycle(cycleStartDate, cutOffDay) {
  if (cutOffDay === 0) {
    // If it's a calendar month, calculate the days of the start month
    const year = cycleStartDate.getFullYear();
    const month = cycleStartDate.getMonth();
    // Day 0 of the next month is the last day of the current month.
    return new Date(year, month + 1, 0).getDate();
  }
  
  // Card Cycle: The cycle ends on the cut-off day of the next month.
  const startYear = cycleStartDate.getFullYear();
  const startMonth = cycleStartDate.getMonth();

  // 1. Calculate the start of the next cycle (Cut-off Day + 1 of month N + 1)
  const nextCycleStartDate = new Date(startYear, startMonth + 1, cutOffDay + 1);
  
  // 2. Calculate the difference in days
  const diffTime = nextCycleStartDate.getTime() - cycleStartDate.getTime();
  // Math.ceil ensures the difference is always an integer and covers any time zone residue.
  const diffDays = Math.ceil(diffTime / (1000 * 3600 * 24));
  
  Logger.log(`Total Days in Cycle: ${diffDays}`);
  return diffDays;
}


// -------------------------------------------------------------
// ðŸ§  GEMINI API CALL FUNCTION FOR ANALYSIS (USING RECOMMENDED MODEL)
// -------------------------------------------------------------

/**
 * Calls Gemini to generate the text report based on the structured data.
 * @param {string} jsonData - JSON with grouped expenses and history.
 * @returns {string} The report generated by the model.
 */
function analyzeDataWithGemini(jsonData) {
  // Ensure the key is available (uses the global constant)
  if (!GEMINI_API_KEY || GEMINI_API_KEY === 'YOUR_GEMINI_API_KEY') {
    return 'Error: The Gemini API key is not configured or is incorrect.';
  }

  const MODEL_NAME = 'gemini-2.5-flash-preview-09-2025';
  const url = `https://generativelanguage.googleapis.com/v1beta/models/${MODEL_NAME}:generateContent?key=${GEMINI_API_KEY}`;
  
  // System instruction to define the role and format
  const systemPrompt = `
    You are a world-class financial analyst. Your response must be a professional, concise, and friendly report in Spanish. Use emojis and Markdown to enhance the presentation.

    The report MUST strictly follow these three sections, without additional headings:
    1. **ðŸ“Š Resumen del Ciclo Actual (Current Cycle Summary):** Total spent, analysis period, and a clear breakdown of expenses by category, with the main category highlighted.
    2. **ðŸ“ˆ AnÃ¡lisis y ProyecciÃ³n (Analysis and Projection):** Calculate the Average Daily Spend (ADS). Based on the 'monthly_history' and current spending, predict the 'Estimated Closing Total' for the cycle and compare it with the historical average.
    3. **ðŸ’¡ RecomendaciÃ³n Financiera (Financial Recommendation):** A concise and actionable tip.
    
    Ensure all amounts are formatted with the 'local_currency' symbol and appropriate thousands/decimal separators for the Hispanic format.
    `;


  // User prompt (the data)
  const userPrompt = `Analyze the following JSON data to generate the report. The prediction must be calculated based on the linear projection of the current daily spend until the end of the cycle: ${jsonData}`;

  try {
    const payload = {
      contents: [{ parts: [{ text: userPrompt }] }],
      systemInstruction: { parts: [{ text: systemPrompt }] }
    };
      
    const response = UrlFetchApp.fetch(url, {
      method: 'post',
      contentType: 'application/json',
      muteHttpExceptions: true,
      payload: JSON.stringify(payload)
    });

    if (response.getResponseCode() !== 200) {
      const errorText = response.getContentText();
      Logger.log(`HTTP Error ${response.getResponseCode()}: ${errorText}. URL: ${url}`);
      return `API Error when generating the report (Code ${response.getResponseCode()}). Check the Apps Script log for details.`;
    }

    const data = JSON.parse(response.getContentText());
    
    // Extract the generated text
    return data.candidates?.[0]?.content?.parts?.[0]?.text || 'Could not generate the report (empty or incomplete response from Gemini).';

  } catch (e) {
    Logger.log(`General error in the report API request: ${e}`);
    return 'Error connecting to the Gemini API: ' + e.toString();
  }
}
